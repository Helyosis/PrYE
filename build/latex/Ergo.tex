%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,french]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsfrench{\renewcommand{\contentsname}{Table des matières:}}

\addto\captionsfrench{\renewcommand{\figurename}{Fig.}}
\addto\captionsfrench{\renewcommand{\tablename}{Tableau}}
\addto\captionsfrench{\renewcommand{\literalblockname}{Code source}}

\addto\captionsfrench{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsfrench{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasfrench{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{Ergo Documentation}
\date{janv. 21, 2019}
\release{1.0}
\author{Delay Desforêts}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Version}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


Ceci est la page d’accueil de la documentation du jeu Ergo.


\chapter{Wiki}
\label{\detokenize{regles::doc}}\label{\detokenize{regles:bienvenue-dans-la-documentation-du-jeu-ergo}}\label{\detokenize{regles:wiki}}

\section{Présentation du jeu}
\label{\detokenize{regles:presentation-du-jeu}}
Le point de départ est le jeu « Ergo » : \sphinxhref{https://www.catalystgamelabs.com/ergo/}{The\_Game\_of\_Proving\_You\_Exist} Vous pouvez retrouver les règles détaillées \sphinxhref{https://www.catalystgamelabs.com/download/Ergo\%20Rules\%202015.pdf.}{ici}

Le jeu est composé de 55 cartes : 4 de chaque variable (A, B, C ou D), 4 de chaque opérateur (ET, OU, =\textgreater{}), 6 cartes NON, 8 parenthèses, 3 cartes Ergo et 10 cartes particulières.

Chaque joueur (4 maximum) se voit assigné une variable (A, B, C ou D) au début du jeu. À chaque manche, les joueurs essaient collectivement de créer une preuve de leur existence tout en réfutant l’existence des autres joueurs. À chaque tour, un joueur pioche deux cartes et doit jouer deux cartes (éventuellement les défausser). Lorsque une carte Ergo est jouée ou qu’il n’y a plus de carte dans la pioche la preuve est terminée. À condition qu’il n’y ait pas de paradoxe, chaque joueur dont l’existence est prouvée reçoit un nombre de points égal au nombre de cartes dans la preuve. Toutes les cartes sont ensuite mélangée et une nouvelle manche est lancée. Le premier joueur ayant 50 points gagne.

Concernant la construction de la preuve, un certain nombre de règles doivent être respectées :
\begin{itemize}
\item {} 
la preuve doit avoir au maximum 4 lignes. Dès qu’elle atteint 4 lignes, toutes les cartes supplémentaires doivent être jouées sur une de ces lignes ;

\item {} 
chaque ligne doit être syntaxiquement correcte (deux opérateurs ou deux variables ne peuvent pas se suivre, chaque parenthèse ouvrante doit correspondre à une parenthèse fermante, dots) ;

\item {} 
une carte peut être insérée entre deux cartes déjà posées à condition que le résultat reste syntaxiquement correct.

\end{itemize}


\section{Le projet}
\label{\detokenize{regles:le-projet}}
Le but est de réaliser une implémentation en Python de ce jeu. Pour cela, je vois plusieurs points à traiter, plus ou moins par ordre de difficulté croissante :
\begin{itemize}
\item {} 
analyser une ligne de la preuve pour vérifier qu’elle est syntaxiquement correcte ;

\item {} 
coder une ligne syntaxiquement correcte sous une forme exploitable (arbre, forme conjonctive normale, forme disjonctive normale, … ?) ;

\item {} 
déterminer à partir du codage des 4 lignes quelles variables sont prouvées ou s’il y a une contradiction ;

\item {} 
réaliser une interface graphique (à priori avec tkinter) ;

\item {} 
implémenter une fonction pour pouvoir jouer contre l’ordinateur.

\end{itemize}

Si on finit tout ça et qu’on a peur de s’ennuyer, on pourra toujours creuser pour améliorer la façon dont l’ordinateur joue. Au pire, on demandera à Frédéric Muller de nous prêter ses TetrisBot pour qu’ils apprennent à jouer à Ergo ;-)


\chapter{Documentation des modules}
\label{\detokenize{doc_classe::doc}}\label{\detokenize{doc_classe:documentation-des-modules}}

\section{Module cards}
\label{\detokenize{doc_classe:module-cards}}\index{cards (module)}
Gestion des cartes et des preuves.
\index{Card (classe dans cards)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Card}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{cards.}\sphinxbfcode{Card}}{\emph{name}}{}
Les cartes du jeu.
\index{\_\_init\_\_() (méthode cards.Card)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Card.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{name}}{}
Constructeur de la classe
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{name} (\sphinxstyleliteralemphasis{string}) \textendash{} nom de la carte (ET, OU, AND, NOT, …)

\item[{Retourne}] \leavevmode
Objet Card

\item[{Type retourné}] \leavevmode
{\hyperref[\detokenize{doc_classe:cards.Card}]{\sphinxcrossref{Card}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_repr\_\_() (méthode cards.Card)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Card.__repr__}}\pysiglinewithargsret{\sphinxbfcode{\_\_repr\_\_}}{}{}~\begin{quote}\begin{description}
\item[{Retourne}] \leavevmode
le nom de la carte.

\item[{Type retourné}] \leavevmode
string

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_weakref\_\_ (attribut cards.Card)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Card.__weakref__}}\pysigline{\sphinxbfcode{\_\_weakref\_\_}}
list of weak references to the object (if defined)

\end{fulllineitems}

\index{is\_close() (méthode cards.Card)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Card.is_close}}\pysiglinewithargsret{\sphinxbfcode{is\_close}}{}{}
Indique si la carte est une parenthèse fermante.
\begin{quote}\begin{description}
\item[{Type retourné}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_ergo() (méthode cards.Card)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Card.is_ergo}}\pysiglinewithargsret{\sphinxbfcode{is\_ergo}}{}{}
Indique si la carte est « Ergo ».
\begin{quote}\begin{description}
\item[{Type retourné}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_letter() (méthode cards.Card)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Card.is_letter}}\pysiglinewithargsret{\sphinxbfcode{is\_letter}}{}{}
Indique si la carte est une lettre ou non.
\begin{quote}\begin{description}
\item[{Type retourné}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_not() (méthode cards.Card)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Card.is_not}}\pysiglinewithargsret{\sphinxbfcode{is\_not}}{}{}
Indique si la carte est un « NOT ».
\begin{quote}\begin{description}
\item[{Type retourné}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_open() (méthode cards.Card)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Card.is_open}}\pysiglinewithargsret{\sphinxbfcode{is\_open}}{}{}
Indique si la carte est une parenthèse ouvrante.
\begin{quote}\begin{description}
\item[{Type retourné}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_operator() (méthode cards.Card)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Card.is_operator}}\pysiglinewithargsret{\sphinxbfcode{is\_operator}}{}{}
Indique si la carte est un opérateur.
\begin{quote}\begin{description}
\item[{Type retourné}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{priority() (méthode cards.Card)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Card.priority}}\pysiglinewithargsret{\sphinxbfcode{priority}}{}{}~\begin{quote}\begin{description}
\item[{Retourne}] \leavevmode
le niveau de priorité de la carte. Si la carte n’a pas de
niveau de priorité, lève une exception.

\item[{Type retourné}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{turn\_parenthesis() (méthode cards.Card)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Card.turn_parenthesis}}\pysiglinewithargsret{\sphinxbfcode{turn\_parenthesis}}{}{}
Retourne la parenthèse, si c’en est une, ne fait rien sinon.

\end{fulllineitems}


\end{fulllineitems}

\index{CardList (classe dans cards)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.CardList}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{cards.}\sphinxbfcode{CardList}}{\emph{*args}}{}
Liste de cartes, avec la Notation Polonaise Inversée associée.
Si la liste ne correspond pas à une preuve syntaxiquement correcte,
NPI vaut None.
\index{\_\_init\_\_() (méthode cards.CardList)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.CardList.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{*args}}{}
Constructeur de la classe.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{args} \textendash{} des arguments pour construire la liste

\item[{Retourne}] \leavevmode
objet CardList initalisé avec les éléments passés par args

\item[{Type retourné}] \leavevmode
{\hyperref[\detokenize{doc_classe:cards.CardList}]{\sphinxcrossref{CardList}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_weakref\_\_ (attribut cards.CardList)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.CardList.__weakref__}}\pysigline{\sphinxbfcode{\_\_weakref\_\_}}
list of weak references to the object (if defined)

\end{fulllineitems}

\index{append() (méthode cards.CardList)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.CardList.append}}\pysiglinewithargsret{\sphinxbfcode{append}}{\emph{card}}{}
Ajoute la carte card à la  fin de la liste.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{card} ({\hyperref[\detokenize{doc_classe:cards.Card}]{\sphinxcrossref{\sphinxstyleliteralemphasis{Card}}}}) \textendash{} la carte à ajouter

\end{description}\end{quote}

\end{fulllineitems}

\index{evalue() (méthode cards.CardList)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.CardList.evalue}}\pysiglinewithargsret{\sphinxbfcode{evalue}}{\emph{interpretation}}{}
Évalue la liste en fonction du modèle. npi doit être calculé.
:param interpretation: liste de 4 booléens correspondant aux valeurs de
A, B, C et D
\begin{quote}\begin{description}
\item[{Retourne}] \leavevmode
Valeur de la liste de carte en fonction du modèle.

\item[{Type retourné}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{insert() (méthode cards.CardList)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.CardList.insert}}\pysiglinewithargsret{\sphinxbfcode{insert}}{\emph{index}, \emph{card}}{}
Insère card à la position index.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{card} ({\hyperref[\detokenize{doc_classe:cards.Card}]{\sphinxcrossref{\sphinxstyleliteralemphasis{Card}}}}) \textendash{} la carte à insérer

\item {} 
\sphinxstyleliteralstrong{index} (\sphinxstyleliteralemphasis{int}) \textendash{} la position à laquelle insérer la carte

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_syntactically\_correct() (méthode cards.CardList)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.CardList.is_syntactically_correct}}\pysiglinewithargsret{\sphinxbfcode{is\_syntactically\_correct}}{}{}
Indique si la liste de cartes est syntaxiquement correcte,
sans s’occuper de la correspondance des parenthèses.
\begin{quote}\begin{description}
\item[{Retourne}] \leavevmode
True si la liste est syntaxiquement correcte, False sinon

\item[{Type retourné}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{pop() (méthode cards.CardList)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.CardList.pop}}\pysiglinewithargsret{\sphinxbfcode{pop}}{\emph{index=-1}}{}
Supprime la carte en position index (par défaut la dernière)
et la renvoie.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{index} (\sphinxstyleliteralemphasis{int}) \textendash{} la position de la carte à renvoyer

\item[{Retourne}] \leavevmode
la carte supprimée

\item[{Type retourné}] \leavevmode
{\hyperref[\detokenize{doc_classe:cards.Card}]{\sphinxcrossref{Card}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{to\_npi() (méthode cards.CardList)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.CardList.to_npi}}\pysiglinewithargsret{\sphinxbfcode{to\_npi}}{}{}
Met à jour self.npi en :
\begin{itemize}
\item {} 
None si la syntaxe de la liste n’est pas correcte

\item {} 
une liste de carte correspondant à la notation polonaise inversée de
la liste de départ sinon.

\end{itemize}

\end{fulllineitems}


\end{fulllineitems}

\index{Deck (classe dans cards)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Deck}}\pysigline{\sphinxbfcode{class }\sphinxcode{cards.}\sphinxbfcode{Deck}}
Le paquet de cartes.
\index{\_\_init\_\_() (méthode cards.Deck)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Deck.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{}{}
Constructeur de la classe
\begin{quote}\begin{description}
\item[{Retourne}] \leavevmode
un paquet de cartes mélangées

\item[{Type retourné}] \leavevmode
{\hyperref[\detokenize{doc_classe:cards.Deck}]{\sphinxcrossref{Deck}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_weakref\_\_ (attribut cards.Deck)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Deck.__weakref__}}\pysigline{\sphinxbfcode{\_\_weakref\_\_}}
list of weak references to the object (if defined)

\end{fulllineitems}

\index{append() (méthode cards.Deck)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Deck.append}}\pysiglinewithargsret{\sphinxbfcode{append}}{\emph{card}}{}
Ajoute une carte (possible avec Tabula Rasa).
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{card} ({\hyperref[\detokenize{doc_classe:cards.Card}]{\sphinxcrossref{\sphinxstyleliteralemphasis{Card}}}}) \textendash{} la carte à ajouter

\end{description}\end{quote}

\end{fulllineitems}

\index{draw() (méthode cards.Deck)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Deck.draw}}\pysiglinewithargsret{\sphinxbfcode{draw}}{\emph{number}}{}~\begin{quote}\begin{description}
\item[{Retourne}] \leavevmode
number cartes du paquet s’il en reste assez, la fin du
paquet ou une liste vide sinon.

\item[{Type retourné}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_finished() (méthode cards.Deck)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Deck.is_finished}}\pysiglinewithargsret{\sphinxbfcode{is\_finished}}{}{}
Indique si la paquet est terminé.
\begin{quote}\begin{description}
\item[{Retourne}] \leavevmode
True si la paquet est terminé, False sinon

\item[{Type retourné}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{reset() (méthode cards.Deck)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Deck.reset}}\pysiglinewithargsret{\sphinxbfcode{reset}}{}{}
Réinitialise le paquet de cartes.

\end{fulllineitems}


\end{fulllineitems}

\index{Proof (classe dans cards)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Proof}}\pysigline{\sphinxbfcode{class }\sphinxcode{cards.}\sphinxbfcode{Proof}}
Classe gérant les prémisses et la preuve.
\index{\_\_init\_\_() (méthode cards.Proof)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Proof.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{}{}
Initialisation des attributs :
\begin{itemize}
\item {} 
premises : liste de 4 CardList correspondant aux 4 lignes de
prémisses;

\item {} 
currently\_added : liste de cartes venant d’être ajoutées aux
prémisses, et pas encore validées.

\end{itemize}
\begin{quote}\begin{description}
\item[{Retourne}] \leavevmode
un objet Proof

\item[{Type retourné}] \leavevmode
{\hyperref[\detokenize{doc_classe:cards.Proof}]{\sphinxcrossref{Proof}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_weakref\_\_ (attribut cards.Proof)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Proof.__weakref__}}\pysigline{\sphinxbfcode{\_\_weakref\_\_}}
list of weak references to the object (if defined)

\end{fulllineitems}

\index{all\_cards\_played() (méthode cards.Proof)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Proof.all_cards_played}}\pysiglinewithargsret{\sphinxbfcode{all\_cards\_played}}{}{}
Indique si chacune des 4 cartes A, B, C et D a été jouée, et donc
s’il est possible de jouer la carte Ergo.
\begin{quote}\begin{description}
\item[{Type retourné}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{conclusion() (méthode cards.Proof)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Proof.conclusion}}\pysiglinewithargsret{\sphinxbfcode{conclusion}}{}{}~\begin{quote}\begin{description}
\item[{Retourne}] \leavevmode
None si les prémisses conduisent à une contradiction,
ou une liste associant à chaque variable “A”, “B”, “C” et “D”
soit True si elle est prouvée, False si la négation est
prouvée, on None si on ne peut rien conclure.

\item[{Type retourné}] \leavevmode
list ou NoneType

\end{description}\end{quote}

\end{fulllineitems}

\index{insert() (méthode cards.Proof)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Proof.insert}}\pysiglinewithargsret{\sphinxbfcode{insert}}{\emph{premise}, \emph{index}, \emph{card}}{}
Insère la carte card dans la prémisse premise en position index
et actualise currently\_added.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{premise} (\sphinxstyleliteralemphasis{int}) \textendash{} le numéro de la prémisse

\item {} 
\sphinxstyleliteralstrong{index} (\sphinxstyleliteralemphasis{int}) \textendash{} la position à laquelle insérer la carte dans la prémisse

\item {} 
\sphinxstyleliteralstrong{card} ({\hyperref[\detokenize{doc_classe:cards.Card}]{\sphinxcrossref{\sphinxstyleliteralemphasis{Card}}}}) \textendash{} la carte à insérer

\end{itemize}

\item[{Retourne}] \leavevmode
True si l’insertion est possible, False sinon.

\item[{Type retourné}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_all\_correct() (méthode cards.Proof)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Proof.is_all_correct}}\pysiglinewithargsret{\sphinxbfcode{is\_all\_correct}}{}{}
Indique si toutes les prémisses sont correctes ou pas.
\begin{quote}\begin{description}
\item[{Type retourné}] \leavevmode
boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{pop() (méthode cards.Proof)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Proof.pop}}\pysiglinewithargsret{\sphinxbfcode{pop}}{\emph{premise}, \emph{index}}{}
Enlève la carte en position index de la prémisse premise à
condition qu’elle vienne d’être ajoutée.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{premise} (\sphinxstyleliteralemphasis{int}) \textendash{} le numéro de la prémisse

\item {} 
\sphinxstyleliteralstrong{index} (\sphinxstyleliteralemphasis{int}) \textendash{} la position dans la prémisse de la carte à supprimer

\end{itemize}

\item[{Retourne}] \leavevmode
la carte en question ou None si on ne peut pas l’enlever.

\item[{Type retourné}] \leavevmode
Card ou NoneType

\end{description}\end{quote}

\end{fulllineitems}

\index{reset\_added() (méthode cards.Proof)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Proof.reset_added}}\pysiglinewithargsret{\sphinxbfcode{reset\_added}}{}{}
Remise à zéro de currently\_added pour le prochain tour.

\end{fulllineitems}

\index{score() (méthode cards.Proof)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:cards.Proof.score}}\pysiglinewithargsret{\sphinxbfcode{score}}{}{}~\begin{quote}\begin{description}
\item[{Retourne}] \leavevmode
Le score correspondant à la preuve, c’est à dire le nombre de
cartes qui la compose.

\item[{Type retourné}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Module gui}
\label{\detokenize{doc_classe:module-gui}}\index{gui (module)}
Interface graphique.
\index{ErgoGui (classe dans gui)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:gui.ErgoGui}}\pysigline{\sphinxbfcode{class }\sphinxcode{gui.}\sphinxbfcode{ErgoGui}}
Interface graphique.
\index{\_\_init\_\_() (méthode gui.ErgoGui)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:gui.ErgoGui.__init__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{}{}
Constructeur de la classe
\begin{quote}\begin{description}
\item[{Retourne}] \leavevmode
Objet ErgoGui

\item[{Type retourné}] \leavevmode
{\hyperref[\detokenize{doc_classe:gui.ErgoGui}]{\sphinxcrossref{ErgoGui}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_canvas\_\_() (méthode gui.ErgoGui)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:gui.ErgoGui.__init_canvas__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_canvas\_\_}}{}{}
Création du canvas de jeu avec les lignes des prémisses, les mains
et noms des joueurs et la pile

\end{fulllineitems}

\index{\_\_init\_menu\_\_() (méthode gui.ErgoGui)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:gui.ErgoGui.__init_menu__}}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_menu\_\_}}{}{}
creation de la barre de menu qui permet d’afficher l’aide,
les règles, la version et de pouvoir quitter le jeu.

\end{fulllineitems}

\index{affiche\_cards() (méthode gui.ErgoGui)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:gui.ErgoGui.affiche_cards}}\pysiglinewithargsret{\sphinxbfcode{affiche\_cards}}{\emph{card\_list}, \emph{row}}{}
affiche la liste de carte card\_list à la ligne row (0 à 3 pour les
prémisses, 4 pour la main du joueur
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{card\_list} (\sphinxstyleliteralemphasis{list}) \textendash{} la liste de cartes à afficher

\item {} 
\sphinxstyleliteralstrong{row} (\sphinxstyleliteralemphasis{int}) \textendash{} le numéro de la ligne

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{display\_current\_player() (méthode gui.ErgoGui)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:gui.ErgoGui.display_current_player}}\pysiglinewithargsret{\sphinxbfcode{display\_current\_player}}{}{}
Affiche les numéros de joueurs en faisant tourner, le joueur
courant est toujours en haut à gauche.

\end{fulllineitems}

\index{drop() (méthode gui.ErgoGui)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:gui.ErgoGui.drop}}\pysiglinewithargsret{\sphinxbfcode{drop}}{\emph{event}}{}
Place la carte marquée « selected » sur la grille, et l’ajoute au bon
endroit (prémisse, main ou pile) et enlève la marque « selected ».
Si c’est impossible, la remet à la fin de la main.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{event} (\sphinxstyleliteralemphasis{tkinter.Event}) \textendash{} événement

\end{description}\end{quote}

\end{fulllineitems}

\index{fin\_manche() (méthode gui.ErgoGui)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:gui.ErgoGui.fin_manche}}\pysiglinewithargsret{\sphinxbfcode{fin\_manche}}{}{}
Fin de la manche, affichage des gagnants et du score.

\end{fulllineitems}

\index{move() (méthode gui.ErgoGui)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:gui.ErgoGui.move}}\pysiglinewithargsret{\sphinxbfcode{move}}{\emph{event}}{}
Déplace la carte marquée « selected ».
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{event} (\sphinxstyleliteralemphasis{tkinter.Event}) \textendash{} événement

\end{description}\end{quote}

\end{fulllineitems}

\index{play() (méthode gui.ErgoGui)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:gui.ErgoGui.play}}\pysiglinewithargsret{\sphinxbfcode{play}}{}{}
Valide un coup si possible, et passe au joueur suivant

\end{fulllineitems}

\index{quitter() (méthode gui.ErgoGui)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:gui.ErgoGui.quitter}}\pysiglinewithargsret{\sphinxbfcode{quitter}}{}{}
Quitte

\end{fulllineitems}

\index{rules() (méthode gui.ErgoGui)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:gui.ErgoGui.rules}}\pysiglinewithargsret{\sphinxbfcode{rules}}{}{}
Affiche les règles du jeu à partir du fichier regles\_ergo.txt

\end{fulllineitems}

\index{select() (méthode gui.ErgoGui)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:gui.ErgoGui.select}}\pysiglinewithargsret{\sphinxbfcode{select}}{\emph{event}}{}
Selectionne une carte, la marque comme « selected », la met en avant
plan, et l’enlève de l’endroit où elle était (mains, prémisse ou pile).
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{event} (\sphinxstyleliteralemphasis{tkinter.Event}) \textendash{} événement

\end{description}\end{quote}

\end{fulllineitems}

\index{switch() (méthode gui.ErgoGui)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:gui.ErgoGui.switch}}\pysiglinewithargsret{\sphinxbfcode{switch}}{\emph{event}}{}
Retourne la parenthèse si c’en est une, dans la main du joueur
courant.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{event} (\sphinxstyleliteralemphasis{tkinter.Event}) \textendash{} événement

\end{description}\end{quote}

\end{fulllineitems}

\index{version() (méthode gui.ErgoGui)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{doc_classe:gui.ErgoGui.version}}\pysiglinewithargsret{\sphinxbfcode{version}}{}{}
Affiche la version du jeu

\end{fulllineitems}


\end{fulllineitems}



\chapter{Index et tables}
\label{\detokenize{index:index-et-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Index des modules Python}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{c}
\item {\sphinxstyleindexentry{cards}}\sphinxstyleindexpageref{doc_classe:\detokenize{module-cards}}
\indexspace
\bigletter{g}
\item {\sphinxstyleindexentry{gui}}\sphinxstyleindexpageref{doc_classe:\detokenize{module-gui}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
\documentclass[12pt, algo]{cours}

\usepackage{pgf-umlcd}

\title{\textbf{\textsc{Ergo -- rapport}}}

\author{Delay Emmanuel-- Desforêts Nicolas}

\makeatletter
\renewcommand{\maketitle}{%
  \thispagestyle{plain}
  \begin{center}%
  \let \footnote \thanks
    {\LARGE \@title \par}%
    \vskip 1.5em%
    {\large \@author}%
  \end{center}%
  \par
  \vskip 1.5em}
\makeatother

% a3_landascape environment
\newenvironment{a3_landscape}
    {\newpage
    \pdfpagewidth=2\pdfpagewidth
    \hsize=2\hsize
    \textwidth=2\textwidth
    \headwidth=\textwidth}
    {\newpage
    \pdfpagewidth=.5\pdfpagewidth
    \hsize=.5\hsize
    \textwidth=.5\textwidth
    \headwidth=\textwidth}


\begin{document}

\maketitle

\tableofcontents

\section{Présentation du projet}

\subsection{Présentation du jeu}

Le point de départ est le jeu \href{https://www.catalystgamelabs.com/ergo/}{Ergo}, \og The Game of Proving You Exist!\fg. Les règles détaillées sont \href{https://www.catalystgamelabs.com/download/Ergo%20Rules%202015.pdf}{ici}.

Le jeu est composé de 55 cartes : 4 de chaque variable (A, B, C ou D), 4 de chaque opérateur (ET, OU, $\implies$), 6 cartes NON, 8 parenthèses, 3 cartes Ergo et 10 cartes particulières.

Chaque joueur (4 maximum) se voit assigné une variable (A, B, C ou D) au début du jeu. À chaque manche, les joueurs essaient collectivement de créer une preuve de leur existence tout en réfutant l'existence des autres joueurs. Au début de la manche, chaque joueur reçoit 5 cartes puis, à chaque tour, un joueur pioche deux cartes et doit jouer deux cartes (éventuellement les défausser). Lorsque une carte Ergo est jouée ou qu'il n'y a plus de carte dans la pioche la preuve est terminée. À condition qu'il n'y ait pas de paradoxe, chaque joueur dont l'existence est prouvée reçoit un nombre de points égal au nombre de cartes dans la preuve. Toutes les cartes sont ensuite mélangées et une nouvelle manche est lancée. Le premier joueur ayant 50 points gagne.

Concernant la construction de la preuve, un certain nombre de règles doivent être respectées~:
\begin{itemize}
\item la preuve doit avoir au maximum 4 lignes. Dès qu'elle atteint 4 lignes, toutes les cartes supplémentaires doivent être jouées sur une de ces lignes~;
\item chaque ligne doit être syntaxiquement correcte (deux opérateurs ou deux variables ne peuvent pas se suivre, chaque parenthèse ouvrante doit correspondre à une parenthèse fermante, \dots)~;
\item une carte peut être insérée entre deux cartes déjà posées à condition que le résultat reste syntaxiquement correct.
\end{itemize}

\subsection{Le projet}

Le but est de réaliser une implémentation en Python de ce jeu. Pour cela, plusieurs points sont à traiter, plus ou moins par ordre de difficulté croissante~:
\nopagebreak
\begin{itemize}
\item analyser une ligne de la preuve pour vérifier qu'elle est syntaxiquement correcte~;
\item coder une ligne syntaxiquement correcte sous une forme exploitable (arbre, forme conjonctive normale, forme disjonctive normale, \dots ?)~;
\item déterminer à partir du codage des 4 lignes quelles variables sont prouvées ou s'il y a une contradiction~;
\item réaliser une interface graphique avec tkinter~;
\item implémenter une fonction pour pouvoir jouer contre l'ordinateur.
\end{itemize}

%Si on finit tout ça et qu'on a peur de s'ennuyer, on pourra toujours creuser pour améliorer la façon dont l'ordinateur joue. Au pire, on demandera à Frédéric Muller de nous prêter ses TetrisBot pour qu'ils apprennent à jouer à Ergo ;-)


\section{Organisation du travail}

\subsection{Outils utilisés}

Nous avons configuré un Rasberry Pi comme serveur pour installer redmine dessus, en nous aidant beaucoup du \href{http://juramaths.fr/redmine/projects/serveur-web-sur-un-raspberry-pi/wiki}{wiki} de Frédéric Muller (merci à lui) et des article de Linux Pratique mis à notre disposition par The Big Boss (loué soit-il).

Nous avons aussi créé un dépôt sur github : \url{https://github.com/isnpaulconstans/Ergo}

La documentation technique est générée avec Sphinx, encore grâce aux articles de GNU/Linux Magasine que notre Big Boss a eu la bonté de nous fournir (Il n'en sera jamais assez remercié \footnote{Le cirage de pompe peut-il augmenter significativement la note de ce module ?}).

Les résultats sont disponibles sur \url{http://paulconstans.ddns.info/redmine/projects/ergo} et sur \url{http://paulconstans.ddns.info/documentation/}.

\subsection{Répartition du travail}

Après quelques discutions, le travail s'est assez naturellement réparti. Emmanuel Delay s'est chargé de la partie algorithmique tandis que Nicolas Desforêts s'est occupé de l'interface graphique et de la réalisation d'une page web pour les règles du jeu. Comme nous travaillons tous les deux dans le même lycée, nous avons pu nous voir régulièrement pour faire la jointure entre nos deux parties et nous mettre d'accord sur les étapes suivantes.

\section{Solutions techniques}

\subsection{Les constantes}

Les différentes constantes pouvant être utiles dans plusieurs classes, comme le nombre de cartes de chaque type, la taille des images correspondante ou les couleurs du canvas, sont rassemblées dans une classe dédiée.

\subsection{Les modules concernant les cartes}

Quatre modules sont destinés à gérer les cartes :

\begin{description}
\item[Card] définit les différentes cartes. Chaque carte a un nom, un niveau de priorité. De nombreuses méthodes permettent de déterminer de quelle carte, ou de qelle famille de carte (lettre, opérateur, joker, \dots) il s'agit. Une méthode permet aussi de \og retourner \fg les parenthèses pour transformer un parenthèse ouvrante en parenthèse fermante et réciproquement. Comme il est parfois nécessaire de comparer deux cartes, la méthode \texttt{\_\_eq\_\_} permet de tester l'égalité de deux cartes (en comparant les noms), ou d'une carte et d'une chaîne de caractères. Les cartes pouvant aussi servir de clé dans un dictionnaire, une fonction de hachage a été implémentée par la méthode \texttt{\_\_hash\_\_}.
\item[CardList], qui hérite de la classe \texttt{list}, gère les listes de cartes. Elle permet d'ajouter, modifier ou supprimer une carte de la liste. Cette classe permet de déterminer si la liste de carte est syntaxiquement correcte, et dans ce cas d'y associer son écriture en notation polonaise inversée (NPI). Un attribut \texttt{modif} permet de savoir si la liste a été modifiée depuis le dernier calcul de la NPI pour éviter de le refaire inutilement.
\item[Proof] gère les quatre prémisses. Elle répercute les modifications (ajout, suppression, changement) aux différentes prémisses et gère leur conjonction pour déterminer la NPI associée à la preuve. Elle permet également de savoir si toutes les lettres ont été jouées (pour pouvoir éventuellement jouer une carte Ergo), et le nombre de cartes jouées (pour calculer le score correspondant). Les méthodes \texttt{insert} et \texttt{pop} ont un paramètre supplémentaire qui permet de gérer deux cas différents pour chacune :
\begin{itemize}
\item l'ajout peut provenir soit d'une nouvelle carte jouée par le joueur soit de l'annulation d'une carte Tabula Rasa qui doit être gérée différemment.
\item De même , la suppression peut soit correspondre à une carte qui vient d'être jouée, soit au jeu d'une carte Tabula Rasa.
\end{itemize}
Pour pouvoir gérer ces différents cas, on maintient une liste \texttt{currently\_added} des numéro de prémisse et index des cartes qui peuvent être modifiées, ainsi qu'un booléen indiquant si la carte correspond à un jeu \og classique \fg (une carte qui vient d'être jouée et qui peut être retirée) ou au jeu d'une carte Tabula Rasa (carte qui a été supprimée par un Tabula Rasa et qui peut être remise). Les indices de cette liste doivent être actualisés à chaque ajout ou suppression de cartes dans les prémisses pour suivre les modifications. Par exemple, si une carte est ajoutée avant une carte mémorisée, l'indice de cette dernière doit être augmenté de 1.
\item[Deck] gère le paquet de cartes.
\end{description}

\subsection{Les modules concernant les démonstrations}

L'analyse de la preuve se fait par la classe abstraite \texttt{Demonstration}. Cette classe est concrétisée par les deux classes \texttt{ForceBrute}, qui cherche à déterminer les \og variables prouvées \fg par force brute, et \texttt{DPLL} qui utilise l'algorithme de Davis-Putnam-Logemann-Loveland. Cette dernière commence par faire appel à la classe \texttt{FCN} pour obtenir l'écriture en forme conjonctive normale de la preuve.


\subsection{L'interface graphique}

Nous utilisons tkinter pour l'interface graphique. Avec en complément messagebox.

Il a fallu créer les images des cartes, en choisissant une dimension pratique pour la gestion du placement de cartes. La première dimension était trop importante et ne permettait pas de faire des lignes de preuve suffisamment longues. Les constantes correspondant à la taille des différentes cartes, à l'épaisseur des traits, au nom ou au nombre de chaque cartes ont été 

Nous avions initialement choisi de créer nos images au format gif, mais à l'usage le format png s'est révélé plus facile à manipuler. L'image carteBack permet d'afficher les mains des autres joueurs face cachée.

\smallskip
Avec les nouvelles fonctionnalités qui permettent de choisir soit le mode multijoueur ou de jouer contre l'ordinateur une nouvelle classe \texttt{ErgoIntro} a été créée. 

Elle permet de créer une fenêtre d’accueil avec une animation au démarrage. La méthode animate\_letter permet de simuler une distribution des cartes suivant la forme des lettres du nom du jeu ERGO.

Deux boutons permettent d'accéder au jeu dans le mode choisi.

\subsection{La classe Main}

La classe \texttt{Main} gère le jeu en lui même et la gestion du \texttt{Canvas} est déléguée à la classe \texttt{ErgoCanvas}. 

La gestion du jeu se fait à la souris. On peut attraper (bouton gauche), déplacer (bouton gauche maintenu) et déposer (bouton gauche relâché) la carte à l'aide des méthodes \texttt{select}, \texttt{move} et \texttt{drop}.

Le bouton droit permet, associé à la méthode \texttt{switch}, si la carte est une parenthèse, de la retourner.

De plus, il s'est avéré qu'il fallait autoriser l'annulation d'une carte effacée avec \texttt{Tabula Rasa} sous peine de bloquer le joueur. C'est possible avec la touche ESC.


Les règles du jeu sont dans un fichier texte. Lors de l'appel de la méthode nous faisons une lecture du fichier puis un affichage dans une fenêtre messagebox.


\section{Algorithmes utilisés}

\subsection{Passage en notation polonaise inversée : algorithme Shunting-yard}

Une des premier problème algorithmique a été de transformer l'écriture algébrique des preuves en une notation plus utilisable. Ayant pas mal travaillé avec mes élèves sur l'évaluation d'une expression en notation polonaise inversée (NPI), je me disais que je devrais arriver à quelque chose si je pouvais transformer l'écriture algébrique en NPI. J'ai fait quelques recherches la dessus, et je suis tombé sur l'algorithme de \href{https://fr.wikipedia.org/wiki/Algorithme_Shunting-yard}{Shunting-yard}.

Je l'ai légèrement adapté au contexte (proposition logique au lieu de d'expression mathématique) pour obtenir l'algorithme \ref{Shunting-yard}.


\begin{algorithm}
\caption{Algorithme de passage en notation polonaise inversée}
\label{Shunting-yard}
\Entree{Une liste \texttt{input} de cartes (propositions ou connecteurs)}
\Sortie{Une liste npi correspondant a la notation polonaise inversée de l'entrée}
\Trait{
Créer une \texttt{pile} vide\;
\texttt{npi} $\leftarrow []$ \;
\PourCh{\texttt{carte} de \texttt{input}}{
	\uSi{\texttt{carte} est une lettre}{ajouter \texttt{carte} à \texttt{npi}}
	\uSinonSi{\texttt{carte} est un parenthèse ouvrante}{empiler \texttt{carte}}
	\uSinonSi{\texttt{carte} est une parenthèse fermante}{
		\Tq{pile est non vide et que le sommet de la pile n'est pas une parenthèse ouvrante}{dépiler une carte et l'ajouter à \texttt{npi}}
		\eSi{pile est vide}{quitter \tcp*[l]{Problème de parenthésage}}{dépiler la parenthèse ouvrante}
		}
	\Sinon{
		\Tq{pile est non vide et que le sommet de la pile a une priorité supérieure à \texttt{carte}}{dépiler une carte et l'ajouter à \texttt{npi}}
		empiler \texttt{carte}
		}
	}
\Tq{pile est non vide}{
	dépiler une carte et l'ajouter à \texttt{npi}\;
	\Si{la carte est une parenthèse ouvrante}{quitter \tcp*[l]{Problème de parenthésage}}
	}
}
\end{algorithm}

\subsection{Évaluation de la preuve}

\subsubsection{Force brute}

Ici, mon idée a été d'attaquer le problème en force brute : tester tous les modèles possible (comme il y a 4 variables, il y a seulement $2^4=16$ possibilités) et pour chacun évaluer la preuve. Si le résultat est Vrai, c'est que le modèle est admissible et on le mémorise. Ensuite, on regarde pour chaque variable si elle a toujours la même valeur (Vrai ou Faux) dans tous les modèles admissibles. Si c'est la cas, la variable est prouvée ou niée.

\medskip
D'après le cours qu'on a eu pour l'instant sur la logique avec Line Jakubie-Jamet, cette méthode constitue une preuve sémantique, mais c'est équivalent à une preuve syntaxique.

\medskip

Pour l'évaluation d'une formule, j'ai utilisé l'algorithme classique d'évaluation d'une expression en NPI (algorithme \ref{evalNPI}).

\begin{algorithm}
\caption{Algorithme d'évaluation d'une formule}
\label{evalNPI}
\Entrees{Une liste \texttt{npi} de carte en NPI et une interprétation}
\Sortie{L'évaluation de la liste}
\Trait{
Créer une pile vide\;
\PourCh{\texttt{carte} de \texttt{npi}}{
	\uSi{\texttt{carte} est une lettre}{empiler sa valeur dans l'interprétation}
	\uSinonSi{\texttt{carte} est un opérateur binaire}{
		dépiler les deux dernières valeurs\;
		effectuer l'opération entre ces valeurs\;
		empiler le résultat
		}
	\Sinon(\tcp*[h]{c'est un opérateur unaire, le NON}){
		dépiler la dernière valeur\;
		empiler sa négation
		}
	}
\Retour{le sommet de \texttt{pile}} \tcp*[l]{qui ne doit avoir qu'un élément}
}
\end{algorithm}

\subsubsection{Algorithme de Davis-Putnam-Logemann-Loveland (DPLL)}

Même si l'algorithme précédent marche bien dans le contexte qui nous intéresse (4 variables propositionnelles), comme l'algorithme DPLL (algorithme \ref{algoDPLL}) nous a été présenté dans le cours de logique, j'ai voulu l'implémenter. Pour cela, il fallait commencer par transformer la preuve au format NPI en une Forme Conjonctive Normale (FCN) sous forme d'une liste de clauses. Cela se fait en 4 étapes :
\begin{itemize}
\item élimination des implications ($A \implies B \equiv \neg A \vee B$) ;
\item utilisation des lois de Morgan ($\neg (A \vee B) \equiv \neg A \wedge \neg B$ et $\neg (A \wedge B) \equiv \neg A \vee \neg B$) ;
\item élimination des doubles négations ($\neg \neg A \equiv A$) ;
\item développement ($A \vee (B \wedge C) \equiv (A \vee B) \wedge (A \vee C)$).
\end{itemize}

\begin{algorithm}
\caption{Algorithme de Davis-Putnam-Logemann-Loveland (DPLL)}
\label{algoDPLL}
\Entrees{Une liste de clauses \texttt{clause\_list} et un modèle partiel \texttt{model}}
\Sortie{Vrai si on peut compléter le modèle partiel en un modèle complet, Faux sinon}
\Trait{
	\Tq{\texttt{clause\_list} contient une clause unitaire \texttt{[lit]}}{
		ajouter la valeur de \texttt{lit} au modèle \;
		supprimer toutes les clauses contenant \texttt{lit} \;
		supprimer $\neg \texttt{lit}$ de toutes les clauses où il apparaît \;
	}
	\lSi{il ne reste plus de clause}{\Retour{Vrai}}
	\lSi{\texttt{clause\_list} contient une clause vide}{\Retour{Faux}}
	\PourCh{variable \texttt{var} non testée}{
		$\texttt{model\_tmp}[\texttt{var}] \leftarrow $ Faux (resp. Vrai)\; 
		\Si(\tcp*[f]{La négation est prouvée}){non DPLL(\texttt{clause\_list}, \texttt{model\_tmp})}{
			$\texttt{model}[\texttt{var}] \leftarrow$ Vrai (resp. Faux) \;
			supprimer toutes les clauses contenant $\neg \texttt{var}$ \;
			supprimer \texttt{var} de toutes les clauses où il apparaît \;
			\Retour{DPLL(\texttt{clause\_list}, \texttt{model})}
		}
	$\texttt{model}[\texttt{var}] \leftarrow None$ \tcp*{\texttt{var} est indécidable}
	}
	\Retour{Vrai} \tcp*{Toutes les variables on été testées}
}

\end{algorithm}

\subsection{Jeu de l'ordinateur}

Le gestion des coups possibles se fait dans la classe \texttt{Ordi}. Cette classe contient une méthode abstraite \texttt{joue} en vue de tester différentes idées concernant les deux cartes à jouer.

Une première étape consiste, si on a au moins deux parenthèses en main, à se débrouiller pour en avoir au moins une ouvrante et une fermante. Pour simplifier la gestion des cartes Fallacy et Justification, une deuxième étape consiste à mettre en premier la carte \texttt{Justification} s'il y en a une. Enfin, on travaille avec une copie de la main dans laquelle les joker (\texttt{WildVar} et \texttt{WildOp}) sont remplacés par une lettre et un opérateur (ça ne change rien à la syntaxe). Pour retrouver les cartes qui étaient initialement des jokers, j'ai ajouté un attribut \texttt{wild} à la classe \texttt{Card} qui mémorise l'état initial de la carte.

\smallskip
Pour la gestion de la carte \texttt{Revolution} (qui permet d'échanger deux cartes), j'ai mis bout à bout les quatre prémisses pour pouvoir plus facilement les parcourir avec seulement deux boucles imbriquées. Pour retrouver les coordonnées initiales (sous forme d'un numéro de prémisse et d'un index), j'ai fait une petite fonction \texttt{index\_flat2premise\_index}.

\smallskip
Si le joueur est sous le coup d'une falsification, il peut soit commencer par jouer une carte \texttt{Justification}, soit jouer une (ou éventuellement deux) carte(s) \texttt{Fallacy} sur un (deux) joueurs. Cette partie étant assez différente du reste, on la traite dans une boucle séparée.

Enfin, on détermine l'ensemble des coups possibles en essayant de jouer chacune des cartes de la main à l'aide de deux boucles imbriquées. Le gestion des cartes spéciales, en particulier celles qui ne se jouent pas dans les prémisses, nécessite l'utilisation d'une variable booléenne \texttt{special1}.

Ces calculs sont réalisés dans la méthode \texttt{coups\_possibles}. Cette méthode est une horreur du point de vue Deep Nesting, mais j'ai eu beau tourner le problème de différentes façons, je n'ai pas réussi à faire plus propre. \footnote{J'espère que Régis Barbanchon, qui nous a fait le cours de PCOO l'an dernier, ne verra pas ça ;-)}

\smallskip
Ensuite, la classe \texttt{OrdiRandom} concrétise la méthode \texttt{joue} en se chargeant de choisir un coup au hasard. Elle joue effectivement les cartes choisies dans les prémisses, et elle renvoie un message à afficher concernant ce jeu. Le gestion des cartes particulières (\texttt{Fallacy}, \texttt{Justification} et \texttt{Ergo}) qui ne concernent pas directement les prémisses est déléguée à la classe appelante.

\section{Évolutions à venir}

\begin{itemize}
\item Proposer une version chronométrée où le joueur a un temps limité pour jouer.
\item Ajouter un bouton \texttt{Cheat} qui indique ce qui est prouvé pour l'instant.
\item Revoir l'esthétique des différents messages, et réécrire la règle du jeu un peu plus précisément. 
\item Tester d'autres méthodes pour le jeu de l'ordinateur. Il faudrait en particulier attribuer un score à chaque coup en fonction de ce qui est prouvé. Ensuite, j'avais éventuellement pensé à un minimax en testant toutes les cartes qui n'ont pas encore été jouées, mais je pense que ça va faire trop de calculs. Peut-être qu'en faisant quelques parties, une stratégie se présentera\dots Sinon, il restera la solution de faire appel à un ami ?
\end{itemize}

\appendix
\begin{a3_landscape}
\section{Diagramme des classes}
\vspace*{-1cm}
\input{"diagramme des classes"}
\end{a3_landscape}
\end{document}

